/**
 * NOTE: This class is auto generated by the swagger code generator program (2.4.27).
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */
package io.swagger.api;

import io.swagger.model.ErrorDetails;
import io.swagger.model.EvolutionResponse;
import org.threeten.bp.LocalDate;
import io.swagger.model.MaskedRecPayment2;
import io.swagger.model.PatchRecurringPaymentConfigItem;
import io.swagger.model.PatchRecurringPaymentsConfigRequest;
import io.swagger.model.PatchUserBrandItem;
import io.swagger.model.PatchUserBrandRequest;
import io.swagger.model.PatchUserBrandsResponse;
import io.swagger.model.ResponsePaginatedBrandExpenses;
import io.swagger.model.ResponsePaginatedMaskedAccount2;
import io.swagger.model.ResponsePaginatedMaskedCard2;
import io.swagger.model.ResponsePaginatedMaskedRecPayment2;
import io.swagger.model.ResponsePaginatedMaskedTransaction2;
import io.swagger.annotations.*;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestHeader;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RequestPart;
import org.springframework.web.multipart.MultipartFile;

import javax.validation.Valid;
import javax.validation.constraints.*;
import java.util.List;
@javax.annotation.Generated(value = "io.swagger.codegen.languages.SpringCodegen", date = "2022-05-31T06:34:04.724Z")

@Validated
@Api(value = "recurring-payments", description = "the recurring-payments API")
@RequestMapping(value = "/crm/subscriptions")
public interface RecurringPaymentsApi {

    @ApiOperation(value = "Returns a list of accounts for a user.", nickname = "getAccounts", notes = "Returns a list of accounts for a user.", response = ResponsePaginatedMaskedAccount2.class, tags={ "Recurring Payment", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "The process finished correctly.", response = ResponsePaginatedMaskedAccount2.class) })
    @RequestMapping(value = "/recurring-payments/accounts",
        produces = { "application/json", "application/xml" }, 
        method = RequestMethod.GET)
    ResponseEntity<ResponsePaginatedMaskedAccount2> getAccounts(@ApiParam(value = "Field to send the access token to the API, initially OAuth and JWT." ,required=true) @RequestHeader(value="authorization", required=true) String authorization,@ApiParam(value = "The server responds with the field in the header with the response language. Following the ([ISO 639-2]-[ISO 3166-1/Alpha3]) code standard." ,required=true) @RequestHeader(value="language", required=true) String language,@ApiParam(value = "CHANNEL/SEGMENT FRONT_APP/VERSION DEVICE OS/OS_VERSION NETWORK_CLIENT/VERSION FRAMEWORK/VERSION Channel: [ISO 639-2][] plus 5 custom contry digits. For Segment: retail / business Front_App/Version: For example OneApp/1.0 Device: Platform value extracted from the device. For example iPhone13 OS/VERSION: android / iOS / windows / linux / macOS, version is a platform value extracted from the device. For example iOS/1.0 Network_Client/Version: App network client and version. For example CF_Network/5.1 Framework/Version: For example Darwin/16.3.0" ,required=true) @RequestHeader(value="device-information", required=true) String deviceInformation,@ApiParam(value = "The consumer application identifier for APIs. santander-client-id must be defined just as a Request header, this is not a header defined as an API Key at security definition level" ,required=true) @RequestHeader(value="santander-client-id", required=true) String santanderClientId,@ApiParam(value = "The consumer list of languages by order of preference. Following the (([ISO 639-2]-[ISO 3166-1/Alpha3])) code standard." ) @RequestHeader(value="accept-language", required=false) String acceptLanguage,@ApiParam(value = "The server responds with the data format of the response. Backend expected a JSON document format." ) @RequestHeader(value="content-type", required=false) String contentType,@ApiParam(value = "The consumer request the data format of the response by order of preference.Backend expected a JSON document format." ) @RequestHeader(value="accept", required=false) String accept,@ApiParam(value = "The consumer application identifier (only for IBM API Connect). Legacy. Will be reviewed in future releases." ) @RequestHeader(value="x-ibm-client-id", required=false) String xIbmClientId,@ApiParam(value = "The TraceId is 64 or 128-bit in length and indicates the overall ID of the trace. Every span in a trace shares this ID" ) @RequestHeader(value="x-b3-traceid", required=false) String xB3Traceid,@ApiParam(value = "The ParentSpanId is 64-bit in length and indicates the position of the parent operation in the trace tree. When the span is the root of the trace tree, there is no ParentSpanId." ) @RequestHeader(value="x-b3-parentspanid", required=false) String xB3Parentspanid,@ApiParam(value = "The SpanId is 64-bit in length and indicates the position of the current operation in the trace tree. The value should not be interpreted. It may or may not be derived from the value of the TraceId" ) @RequestHeader(value="x-b3-spanid", required=false) String xB3Spanid,@ApiParam(value = "Sampling is a mechanism to reduce the volume of data that ends up in the tracing system. In B3, sampling applies consistently per-trace: once the sampling decision is made, the same value should be consistently sent downstream. This means you will see all spans sharing a trace ID or none. Accepted values are\\n * 1. Means accepted\\n * 0. Means denied Before this specification was written, some tracers propagated X-B3-Sampled as true or false as opposed to 1 or 0. While you shouldn't encode x-b3-sampled as true or false, a lenient implementation may accept them" ) @RequestHeader(value="x-b3-sampled", required=false) String xB3Sampled,@ApiParam(value = "Extra information coming from the client. Needed for audit purposes" ) @RequestHeader(value="x-santander-audit", required=false) String xSantanderAudit,@ApiParam(value = "Device information permitted by operation for data query. Makes it possible to apply an experience base to optimize the data collection. This header is mandatory for Poland due to security reasons" ) @RequestHeader(value="trusted-device-app-id", required=false) String trustedDeviceAppId,@ApiParam(value = "Indicates what kind of cipher algorithmic approach will be applied to a response fields subset. Supported values: * asymmetric" ) @RequestHeader(value="santander-cipher-type", required=false) String santanderCipherType,@ApiParam(value = "Seed value applied on both sides to encrypt/decrypt response entity fields. This field is mandatory if Santander-Cipher-Type is presented and is asymetric in the request Headers collection." ) @RequestHeader(value="santander-cipher-seed", required=false) String santanderCipherSeed,@ApiParam(value = "Device time formatted presenting the following the Standard Time Format pattern yyyy-MM-dd'T'HH:mm:ss.SSS'Z'" ) @RequestHeader(value="trusted-device-time", required=false) String trustedDeviceTime,@ApiParam(value = "Contains encripted parameters from the trusted device parameter source." ) @RequestHeader(value="trusted-device-params", required=false) String trustedDeviceParams,@ApiParam(value = "Filter by page (paging)") @Valid @RequestParam(value = "offset", required = false) Integer offset,@ApiParam(value = "Specify the number of elements per page (paging).") @Valid @RequestParam(value = "limit", required = false) Integer limit,@ApiParam(value = "Field that we want to sort.") @Valid @RequestParam(value = "sort", required = false) String sort,@ApiParam(value = "Direction we want to sort.") @Valid @RequestParam(value = "dir", required = false) String dir,@ApiParam(value = "Show only elements that have enabled recurring payments.") @Valid @RequestParam(value = "forceHasRecurringPaymentsEnabled", required = false) Boolean forceHasRecurringPaymentsEnabled);


    @ApiOperation(value = "Calculates and returns a paginated list of brands with payment details associated to them.", nickname = "getBrandExpenses", notes = "Calculates and returns a paginated list of brands with payment details associated to them. Requires either a card id or an account id to perform the operation.", response = ResponsePaginatedBrandExpenses.class, tags={ "Recurring Payment", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "The process finished correctly.", response = ResponsePaginatedBrandExpenses.class),
        @ApiResponse(code = 404, message = "The given account does not exist.", response = ErrorDetails.class),
        @ApiResponse(code = 490, message = "The given does not exist.", response = ErrorDetails.class) })
    @RequestMapping(value = "/recurring-payments/brand-expenses",
        produces = { "application/json", "application/xml" }, 
        method = RequestMethod.GET)
    ResponseEntity<ResponsePaginatedBrandExpenses> getBrandExpenses(@ApiParam(value = "Field to send the access token to the API, initially OAuth and JWT." ,required=true) @RequestHeader(value="authorization", required=true) String authorization,@ApiParam(value = "The server responds with the field in the header with the response language. Following the ([ISO 639-2]-[ISO 3166-1/Alpha3]) code standard." ,required=true) @RequestHeader(value="language", required=true) String language,@ApiParam(value = "CHANNEL/SEGMENT FRONT_APP/VERSION DEVICE OS/OS_VERSION NETWORK_CLIENT/VERSION FRAMEWORK/VERSION Channel: [ISO 639-2][] plus 5 custom contry digits. For Segment: retail / business Front_App/Version: For example OneApp/1.0 Device: Platform value extracted from the device. For example iPhone13 OS/VERSION: android / iOS / windows / linux / macOS, version is a platform value extracted from the device. For example iOS/1.0 Network_Client/Version: App network client and version. For example CF_Network/5.1 Framework/Version: For example Darwin/16.3.0" ,required=true) @RequestHeader(value="device-information", required=true) String deviceInformation,@ApiParam(value = "The consumer application identifier for APIs. santander-client-id must be defined just as a Request header, this is not a header defined as an API Key at security definition level" ,required=true) @RequestHeader(value="santander-client-id", required=true) String santanderClientId,@ApiParam(value = "The consumer list of languages by order of preference. Following the (([ISO 639-2]-[ISO 3166-1/Alpha3])) code standard." ) @RequestHeader(value="accept-language", required=false) String acceptLanguage,@ApiParam(value = "The server responds with the data format of the response. Backend expected a JSON document format." ) @RequestHeader(value="content-type", required=false) String contentType,@ApiParam(value = "The consumer request the data format of the response by order of preference.Backend expected a JSON document format." ) @RequestHeader(value="accept", required=false) String accept,@ApiParam(value = "The consumer application identifier (only for IBM API Connect). Legacy. Will be reviewed in future releases." ) @RequestHeader(value="x-ibm-client-id", required=false) String xIbmClientId,@ApiParam(value = "The TraceId is 64 or 128-bit in length and indicates the overall ID of the trace. Every span in a trace shares this ID" ) @RequestHeader(value="x-b3-traceid", required=false) String xB3Traceid,@ApiParam(value = "The ParentSpanId is 64-bit in length and indicates the position of the parent operation in the trace tree. When the span is the root of the trace tree, there is no ParentSpanId." ) @RequestHeader(value="x-b3-parentspanid", required=false) String xB3Parentspanid,@ApiParam(value = "The SpanId is 64-bit in length and indicates the position of the current operation in the trace tree. The value should not be interpreted. It may or may not be derived from the value of the TraceId" ) @RequestHeader(value="x-b3-spanid", required=false) String xB3Spanid,@ApiParam(value = "Sampling is a mechanism to reduce the volume of data that ends up in the tracing system. In B3, sampling applies consistently per-trace: once the sampling decision is made, the same value should be consistently sent downstream. This means you will see all spans sharing a trace ID or none. Accepted values are\\n * 1. Means accepted\\n * 0. Means denied Before this specification was written, some tracers propagated X-B3-Sampled as true or false as opposed to 1 or 0. While you shouldn't encode x-b3-sampled as true or false, a lenient implementation may accept them" ) @RequestHeader(value="x-b3-sampled", required=false) String xB3Sampled,@ApiParam(value = "Extra information coming from the client. Needed for audit purposes" ) @RequestHeader(value="x-santander-audit", required=false) String xSantanderAudit,@ApiParam(value = "Device information permitted by operation for data query. Makes it possible to apply an experience base to optimize the data collection. This header is mandatory for Poland due to security reasons" ) @RequestHeader(value="trusted-device-app-id", required=false) String trustedDeviceAppId,@ApiParam(value = "Indicates what kind of cipher algorithmic approach will be applied to a response fields subset. Supported values: * asymmetric" ) @RequestHeader(value="santander-cipher-type", required=false) String santanderCipherType,@ApiParam(value = "Seed value applied on both sides to encrypt/decrypt response entity fields. This field is mandatory if Santander-Cipher-Type is presented and is asymetric in the request Headers collection." ) @RequestHeader(value="santander-cipher-seed", required=false) String santanderCipherSeed,@ApiParam(value = "Device time formatted presenting the following the Standard Time Format pattern yyyy-MM-dd'T'HH:mm:ss.SSS'Z'" ) @RequestHeader(value="trusted-device-time", required=false) String trustedDeviceTime,@ApiParam(value = "Contains encripted parameters from the trusted device parameter source." ) @RequestHeader(value="trusted-device-params", required=false) String trustedDeviceParams,@ApiParam(value = "Id associated to an account. Length : 36 characters.") @Valid @RequestParam(value = "accountId", required = false) String accountId,@ApiParam(value = "Id associated to a card. Length : 36 characters.") @Valid @RequestParam(value = "cardId", required = false) String cardId,@ApiParam(value = "Name of the brand that we want to sort. Max length : 255 characters.") @Valid @RequestParam(value = "brand_name", required = false) String brandName,@ApiParam(value = "Control if the user have enabled a special configuration for the brand.") @Valid @RequestParam(value = "enabled", required = false) Boolean enabled,@ApiParam(value = "If the recurring payment have to be done again or not.") @Valid @RequestParam(value = "active", required = false) Boolean active,@ApiParam(value = "The type associated to the recurring payment.") @Valid @RequestParam(value = "recurringPaymentType", required = false) String recurringPaymentType,@ApiParam(value = "If the payment method in the recurring payments is ignored for the aggregation process") @Valid @RequestParam(value = "isUserRp", required = false) Boolean isUserRp,@ApiParam(value = "Filter by page (paging)") @Valid @RequestParam(value = "offset", required = false) Integer offset,@ApiParam(value = "Specify the number of elements per page (paging).") @Valid @RequestParam(value = "limit", required = false) Integer limit,@ApiParam(value = "Field that we want to sort.") @Valid @RequestParam(value = "sort", required = false) String sort,@ApiParam(value = "Direction we want to sort.") @Valid @RequestParam(value = "dir", required = false) String dir);


    @ApiOperation(value = "Returns a list of cards for a user.", nickname = "getCards", notes = "Returns a list of cards for a user.", response = ResponsePaginatedMaskedCard2.class, tags={ "Recurring Payment", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "The process finished correctly.", response = ResponsePaginatedMaskedCard2.class) })
    @RequestMapping(value = "/recurring-payments/cards",
        produces = { "application/json", "application/xml" }, 
        method = RequestMethod.GET)
    ResponseEntity<ResponsePaginatedMaskedCard2> getCards(@ApiParam(value = "Field to send the access token to the API, initially OAuth and JWT." ,required=true) @RequestHeader(value="authorization", required=true) String authorization,@ApiParam(value = "The server responds with the field in the header with the response language. Following the ([ISO 639-2]-[ISO 3166-1/Alpha3]) code standard." ,required=true) @RequestHeader(value="language", required=true) String language,@ApiParam(value = "CHANNEL/SEGMENT FRONT_APP/VERSION DEVICE OS/OS_VERSION NETWORK_CLIENT/VERSION FRAMEWORK/VERSION Channel: [ISO 639-2][] plus 5 custom contry digits. For Segment: retail / business Front_App/Version: For example OneApp/1.0 Device: Platform value extracted from the device. For example iPhone13 OS/VERSION: android / iOS / windows / linux / macOS, version is a platform value extracted from the device. For example iOS/1.0 Network_Client/Version: App network client and version. For example CF_Network/5.1 Framework/Version: For example Darwin/16.3.0" ,required=true) @RequestHeader(value="device-information", required=true) String deviceInformation,@ApiParam(value = "The consumer application identifier for APIs. santander-client-id must be defined just as a Request header, this is not a header defined as an API Key at security definition level" ,required=true) @RequestHeader(value="santander-client-id", required=true) String santanderClientId,@ApiParam(value = "The consumer list of languages by order of preference. Following the (([ISO 639-2]-[ISO 3166-1/Alpha3])) code standard." ) @RequestHeader(value="accept-language", required=false) String acceptLanguage,@ApiParam(value = "The server responds with the data format of the response. Backend expected a JSON document format." ) @RequestHeader(value="content-type", required=false) String contentType,@ApiParam(value = "The consumer request the data format of the response by order of preference.Backend expected a JSON document format." ) @RequestHeader(value="accept", required=false) String accept,@ApiParam(value = "The consumer application identifier (only for IBM API Connect). Legacy. Will be reviewed in future releases." ) @RequestHeader(value="x-ibm-client-id", required=false) String xIbmClientId,@ApiParam(value = "The TraceId is 64 or 128-bit in length and indicates the overall ID of the trace. Every span in a trace shares this ID" ) @RequestHeader(value="x-b3-traceid", required=false) String xB3Traceid,@ApiParam(value = "The ParentSpanId is 64-bit in length and indicates the position of the parent operation in the trace tree. When the span is the root of the trace tree, there is no ParentSpanId." ) @RequestHeader(value="x-b3-parentspanid", required=false) String xB3Parentspanid,@ApiParam(value = "The SpanId is 64-bit in length and indicates the position of the current operation in the trace tree. The value should not be interpreted. It may or may not be derived from the value of the TraceId" ) @RequestHeader(value="x-b3-spanid", required=false) String xB3Spanid,@ApiParam(value = "Sampling is a mechanism to reduce the volume of data that ends up in the tracing system. In B3, sampling applies consistently per-trace: once the sampling decision is made, the same value should be consistently sent downstream. This means you will see all spans sharing a trace ID or none. Accepted values are\\n * 1. Means accepted\\n * 0. Means denied Before this specification was written, some tracers propagated X-B3-Sampled as true or false as opposed to 1 or 0. While you shouldn't encode x-b3-sampled as true or false, a lenient implementation may accept them" ) @RequestHeader(value="x-b3-sampled", required=false) String xB3Sampled,@ApiParam(value = "Extra information coming from the client. Needed for audit purposes" ) @RequestHeader(value="x-santander-audit", required=false) String xSantanderAudit,@ApiParam(value = "Device information permitted by operation for data query. Makes it possible to apply an experience base to optimize the data collection. This header is mandatory for Poland due to security reasons" ) @RequestHeader(value="trusted-device-app-id", required=false) String trustedDeviceAppId,@ApiParam(value = "Indicates what kind of cipher algorithmic approach will be applied to a response fields subset. Supported values: * asymmetric" ) @RequestHeader(value="santander-cipher-type", required=false) String santanderCipherType,@ApiParam(value = "Seed value applied on both sides to encrypt/decrypt response entity fields. This field is mandatory if Santander-Cipher-Type is presented and is asymetric in the request Headers collection." ) @RequestHeader(value="santander-cipher-seed", required=false) String santanderCipherSeed,@ApiParam(value = "Device time formatted presenting the following the Standard Time Format pattern yyyy-MM-dd'T'HH:mm:ss.SSS'Z'" ) @RequestHeader(value="trusted-device-time", required=false) String trustedDeviceTime,@ApiParam(value = "Contains encripted parameters from the trusted device parameter source." ) @RequestHeader(value="trusted-device-params", required=false) String trustedDeviceParams,@ApiParam(value = "Filter by page (paging)") @Valid @RequestParam(value = "offset", required = false) Integer offset,@ApiParam(value = "Specify the number of elements per page (paging).") @Valid @RequestParam(value = "limit", required = false) Integer limit,@ApiParam(value = "Field that we want to sort.") @Valid @RequestParam(value = "sort", required = false) String sort,@ApiParam(value = "Direction we want to sort.") @Valid @RequestParam(value = "dir", required = false) String dir,@ApiParam(value = "Show only elements that have enabled recurring payments.") @Valid @RequestParam(value = "forceHasRecurringPaymentsEnabled", required = false) Boolean forceHasRecurringPaymentsEnabled);


    @ApiOperation(value = "Returns the data needed to show the evolution chart.", nickname = "getEvolution", notes = "Returns the data needed to show the evolution chart, grouped by categories, related to the given user id.", response = EvolutionResponse.class, tags={ "Recurring Payment", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "The process finished correctly.", response = EvolutionResponse.class),
        @ApiResponse(code = 400, message = "Invalid date range.", response = ErrorDetails.class) })
    @RequestMapping(value = "/recurring-payments/evolution",
        produces = { "application/json", "application/xml" }, 
        method = RequestMethod.GET)
    ResponseEntity<EvolutionResponse> getEvolution(@ApiParam(value = "Field to send the access token to the API, initially OAuth and JWT." ,required=true) @RequestHeader(value="authorization", required=true) String authorization,@ApiParam(value = "The server responds with the field in the header with the response language. Following the ([ISO 639-2]-[ISO 3166-1/Alpha3]) code standard." ,required=true) @RequestHeader(value="language", required=true) String language,@ApiParam(value = "CHANNEL/SEGMENT FRONT_APP/VERSION DEVICE OS/OS_VERSION NETWORK_CLIENT/VERSION FRAMEWORK/VERSION Channel: [ISO 639-2][] plus 5 custom contry digits. For Segment: retail / business Front_App/Version: For example OneApp/1.0 Device: Platform value extracted from the device. For example iPhone13 OS/VERSION: android / iOS / windows / linux / macOS, version is a platform value extracted from the device. For example iOS/1.0 Network_Client/Version: App network client and version. For example CF_Network/5.1 Framework/Version: For example Darwin/16.3.0" ,required=true) @RequestHeader(value="device-information", required=true) String deviceInformation,@ApiParam(value = "The consumer application identifier for APIs. santander-client-id must be defined just as a Request header, this is not a header defined as an API Key at security definition level" ,required=true) @RequestHeader(value="santander-client-id", required=true) String santanderClientId,@NotNull @ApiParam(value = "Initial date since we want to filter.", required = true) @Valid @RequestParam(value = "dateFrom", required = true) String dateFrom,@NotNull @ApiParam(value = "Last date that we want to filter.", required = true) @Valid @RequestParam(value = "dateTo", required = true) String dateTo,@ApiParam(value = "The consumer list of languages by order of preference. Following the (([ISO 639-2]-[ISO 3166-1/Alpha3])) code standard." ) @RequestHeader(value="accept-language", required=false) String acceptLanguage,@ApiParam(value = "The server responds with the data format of the response. Backend expected a JSON document format." ) @RequestHeader(value="content-type", required=false) String contentType,@ApiParam(value = "The consumer request the data format of the response by order of preference.Backend expected a JSON document format." ) @RequestHeader(value="accept", required=false) String accept,@ApiParam(value = "The consumer application identifier (only for IBM API Connect). Legacy. Will be reviewed in future releases." ) @RequestHeader(value="x-ibm-client-id", required=false) String xIbmClientId,@ApiParam(value = "The TraceId is 64 or 128-bit in length and indicates the overall ID of the trace. Every span in a trace shares this ID" ) @RequestHeader(value="x-b3-traceid", required=false) String xB3Traceid,@ApiParam(value = "The ParentSpanId is 64-bit in length and indicates the position of the parent operation in the trace tree. When the span is the root of the trace tree, there is no ParentSpanId." ) @RequestHeader(value="x-b3-parentspanid", required=false) String xB3Parentspanid,@ApiParam(value = "The SpanId is 64-bit in length and indicates the position of the current operation in the trace tree. The value should not be interpreted. It may or may not be derived from the value of the TraceId" ) @RequestHeader(value="x-b3-spanid", required=false) String xB3Spanid,@ApiParam(value = "Sampling is a mechanism to reduce the volume of data that ends up in the tracing system. In B3, sampling applies consistently per-trace: once the sampling decision is made, the same value should be consistently sent downstream. This means you will see all spans sharing a trace ID or none. Accepted values are\\n * 1. Means accepted\\n * 0. Means denied Before this specification was written, some tracers propagated X-B3-Sampled as true or false as opposed to 1 or 0. While you shouldn't encode x-b3-sampled as true or false, a lenient implementation may accept them" ) @RequestHeader(value="x-b3-sampled", required=false) String xB3Sampled,@ApiParam(value = "Extra information coming from the client. Needed for audit purposes" ) @RequestHeader(value="x-santander-audit", required=false) String xSantanderAudit,@ApiParam(value = "Device information permitted by operation for data query. Makes it possible to apply an experience base to optimize the data collection. This header is mandatory for Poland due to security reasons" ) @RequestHeader(value="trusted-device-app-id", required=false) String trustedDeviceAppId,@ApiParam(value = "Indicates what kind of cipher algorithmic approach will be applied to a response fields subset. Supported values: * asymmetric" ) @RequestHeader(value="santander-cipher-type", required=false) String santanderCipherType,@ApiParam(value = "Seed value applied on both sides to encrypt/decrypt response entity fields. This field is mandatory if Santander-Cipher-Type is presented and is asymetric in the request Headers collection." ) @RequestHeader(value="santander-cipher-seed", required=false) String santanderCipherSeed,@ApiParam(value = "Device time formatted presenting the following the Standard Time Format pattern yyyy-MM-dd'T'HH:mm:ss.SSS'Z'" ) @RequestHeader(value="trusted-device-time", required=false) String trustedDeviceTime,@ApiParam(value = "Contains encripted parameters from the trusted device parameter source." ) @RequestHeader(value="trusted-device-params", required=false) String trustedDeviceParams,@ApiParam(value = "If the payment method in the recurring payments is ignored for the aggregation process") @Valid @RequestParam(value = "isUserRp", required = false) Boolean isUserRp);


    @ApiOperation(value = "Gets the subscription entity associated to its given id.", nickname = "getRecurringPaymentById", notes = "Gets the recurring payment associated to the id.", response = MaskedRecPayment2.class, tags={ "Recurring Payment", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "The process finished correctly.", response = MaskedRecPayment2.class),
        @ApiResponse(code = 403, message = "The recurring payment is not associated with your user id.", response = ErrorDetails.class),
        @ApiResponse(code = 404, message = "The recurring payment with the given id does not exist.", response = ErrorDetails.class) })
    @RequestMapping(value = "/recurring-payments/{id}",
        produces = { "application/json", "application/xml" }, 
        method = RequestMethod.GET)
    ResponseEntity<MaskedRecPayment2> getRecurringPaymentById(@ApiParam(value = "Field to send the access token to the API, initially OAuth and JWT." ,required=true) @RequestHeader(value="authorization", required=true) String authorization,@ApiParam(value = "The server responds with the field in the header with the response language. Following the ([ISO 639-2]-[ISO 3166-1/Alpha3]) code standard." ,required=true) @RequestHeader(value="language", required=true) String language,@ApiParam(value = "CHANNEL/SEGMENT FRONT_APP/VERSION DEVICE OS/OS_VERSION NETWORK_CLIENT/VERSION FRAMEWORK/VERSION Channel: [ISO 639-2][] plus 5 custom contry digits. For Segment: retail / business Front_App/Version: For example OneApp/1.0 Device: Platform value extracted from the device. For example iPhone13 OS/VERSION: android / iOS / windows / linux / macOS, version is a platform value extracted from the device. For example iOS/1.0 Network_Client/Version: App network client and version. For example CF_Network/5.1 Framework/Version: For example Darwin/16.3.0" ,required=true) @RequestHeader(value="device-information", required=true) String deviceInformation,@ApiParam(value = "The consumer application identifier for APIs. santander-client-id must be defined just as a Request header, this is not a header defined as an API Key at security definition level" ,required=true) @RequestHeader(value="santander-client-id", required=true) String santanderClientId,@ApiParam(value = "Id of the recurring payment we want to search. Length : 36 characters.",required=true) @PathVariable("id") String id,@ApiParam(value = "The consumer list of languages by order of preference. Following the (([ISO 639-2]-[ISO 3166-1/Alpha3])) code standard." ) @RequestHeader(value="accept-language", required=false) String acceptLanguage,@ApiParam(value = "The server responds with the data format of the response. Backend expected a JSON document format." ) @RequestHeader(value="content-type", required=false) String contentType,@ApiParam(value = "The consumer request the data format of the response by order of preference.Backend expected a JSON document format." ) @RequestHeader(value="accept", required=false) String accept,@ApiParam(value = "The consumer application identifier (only for IBM API Connect). Legacy. Will be reviewed in future releases." ) @RequestHeader(value="x-ibm-client-id", required=false) String xIbmClientId,@ApiParam(value = "The TraceId is 64 or 128-bit in length and indicates the overall ID of the trace. Every span in a trace shares this ID" ) @RequestHeader(value="x-b3-traceid", required=false) String xB3Traceid,@ApiParam(value = "The ParentSpanId is 64-bit in length and indicates the position of the parent operation in the trace tree. When the span is the root of the trace tree, there is no ParentSpanId." ) @RequestHeader(value="x-b3-parentspanid", required=false) String xB3Parentspanid,@ApiParam(value = "The SpanId is 64-bit in length and indicates the position of the current operation in the trace tree. The value should not be interpreted. It may or may not be derived from the value of the TraceId" ) @RequestHeader(value="x-b3-spanid", required=false) String xB3Spanid,@ApiParam(value = "Sampling is a mechanism to reduce the volume of data that ends up in the tracing system. In B3, sampling applies consistently per-trace: once the sampling decision is made, the same value should be consistently sent downstream. This means you will see all spans sharing a trace ID or none. Accepted values are\\n * 1. Means accepted\\n * 0. Means denied Before this specification was written, some tracers propagated X-B3-Sampled as true or false as opposed to 1 or 0. While you shouldn't encode x-b3-sampled as true or false, a lenient implementation may accept them" ) @RequestHeader(value="x-b3-sampled", required=false) String xB3Sampled,@ApiParam(value = "Extra information coming from the client. Needed for audit purposes" ) @RequestHeader(value="x-santander-audit", required=false) String xSantanderAudit,@ApiParam(value = "Device information permitted by operation for data query. Makes it possible to apply an experience base to optimize the data collection. This header is mandatory for Poland due to security reasons" ) @RequestHeader(value="trusted-device-app-id", required=false) String trustedDeviceAppId,@ApiParam(value = "Indicates what kind of cipher algorithmic approach will be applied to a response fields subset. Supported values: * asymmetric" ) @RequestHeader(value="santander-cipher-type", required=false) String santanderCipherType,@ApiParam(value = "Seed value applied on both sides to encrypt/decrypt response entity fields. This field is mandatory if Santander-Cipher-Type is presented and is asymetric in the request Headers collection." ) @RequestHeader(value="santander-cipher-seed", required=false) String santanderCipherSeed,@ApiParam(value = "Device time formatted presenting the following the Standard Time Format pattern yyyy-MM-dd'T'HH:mm:ss.SSS'Z'" ) @RequestHeader(value="trusted-device-time", required=false) String trustedDeviceTime,@ApiParam(value = "Contains encripted parameters from the trusted device parameter source." ) @RequestHeader(value="trusted-device-params", required=false) String trustedDeviceParams);


    @ApiOperation(value = "Gets a paginated list of recurring payment entities, with possible filtering.", nickname = "getRecurringPayments", notes = "Gets a paginated list of recurring payment entities, with possible filtering.", response = ResponsePaginatedMaskedRecPayment2.class, tags={ "Recurring Payment", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "The process finished correctly.", response = ResponsePaginatedMaskedRecPayment2.class) })
    @RequestMapping(value = "/recurring-payments",
        produces = { "application/json", "application/xml" }, 
        method = RequestMethod.GET)
    ResponseEntity<ResponsePaginatedMaskedRecPayment2> getRecurringPayments(@ApiParam(value = "Field to send the access token to the API, initially OAuth and JWT." ,required=true) @RequestHeader(value="authorization", required=true) String authorization,@ApiParam(value = "The server responds with the field in the header with the response language. Following the ([ISO 639-2]-[ISO 3166-1/Alpha3]) code standard." ,required=true) @RequestHeader(value="language", required=true) String language,@ApiParam(value = "CHANNEL/SEGMENT FRONT_APP/VERSION DEVICE OS/OS_VERSION NETWORK_CLIENT/VERSION FRAMEWORK/VERSION Channel: [ISO 639-2][] plus 5 custom contry digits. For Segment: retail / business Front_App/Version: For example OneApp/1.0 Device: Platform value extracted from the device. For example iPhone13 OS/VERSION: android / iOS / windows / linux / macOS, version is a platform value extracted from the device. For example iOS/1.0 Network_Client/Version: App network client and version. For example CF_Network/5.1 Framework/Version: For example Darwin/16.3.0" ,required=true) @RequestHeader(value="device-information", required=true) String deviceInformation,@ApiParam(value = "The consumer application identifier for APIs. santander-client-id must be defined just as a Request header, this is not a header defined as an API Key at security definition level" ,required=true) @RequestHeader(value="santander-client-id", required=true) String santanderClientId,@ApiParam(value = "The consumer list of languages by order of preference. Following the (([ISO 639-2]-[ISO 3166-1/Alpha3])) code standard." ) @RequestHeader(value="accept-language", required=false) String acceptLanguage,@ApiParam(value = "The server responds with the data format of the response. Backend expected a JSON document format." ) @RequestHeader(value="content-type", required=false) String contentType,@ApiParam(value = "The consumer request the data format of the response by order of preference.Backend expected a JSON document format." ) @RequestHeader(value="accept", required=false) String accept,@ApiParam(value = "The consumer application identifier (only for IBM API Connect). Legacy. Will be reviewed in future releases." ) @RequestHeader(value="x-ibm-client-id", required=false) String xIbmClientId,@ApiParam(value = "The TraceId is 64 or 128-bit in length and indicates the overall ID of the trace. Every span in a trace shares this ID" ) @RequestHeader(value="x-b3-traceid", required=false) String xB3Traceid,@ApiParam(value = "The ParentSpanId is 64-bit in length and indicates the position of the parent operation in the trace tree. When the span is the root of the trace tree, there is no ParentSpanId." ) @RequestHeader(value="x-b3-parentspanid", required=false) String xB3Parentspanid,@ApiParam(value = "The SpanId is 64-bit in length and indicates the position of the current operation in the trace tree. The value should not be interpreted. It may or may not be derived from the value of the TraceId" ) @RequestHeader(value="x-b3-spanid", required=false) String xB3Spanid,@ApiParam(value = "Sampling is a mechanism to reduce the volume of data that ends up in the tracing system. In B3, sampling applies consistently per-trace: once the sampling decision is made, the same value should be consistently sent downstream. This means you will see all spans sharing a trace ID or none. Accepted values are\\n * 1. Means accepted\\n * 0. Means denied Before this specification was written, some tracers propagated X-B3-Sampled as true or false as opposed to 1 or 0. While you shouldn't encode x-b3-sampled as true or false, a lenient implementation may accept them" ) @RequestHeader(value="x-b3-sampled", required=false) String xB3Sampled,@ApiParam(value = "Extra information coming from the client. Needed for audit purposes" ) @RequestHeader(value="x-santander-audit", required=false) String xSantanderAudit,@ApiParam(value = "Device information permitted by operation for data query. Makes it possible to apply an experience base to optimize the data collection. This header is mandatory for Poland due to security reasons" ) @RequestHeader(value="trusted-device-app-id", required=false) String trustedDeviceAppId,@ApiParam(value = "Indicates what kind of cipher algorithmic approach will be applied to a response fields subset. Supported values: * asymmetric" ) @RequestHeader(value="santander-cipher-type", required=false) String santanderCipherType,@ApiParam(value = "Seed value applied on both sides to encrypt/decrypt response entity fields. This field is mandatory if Santander-Cipher-Type is presented and is asymetric in the request Headers collection." ) @RequestHeader(value="santander-cipher-seed", required=false) String santanderCipherSeed,@ApiParam(value = "Device time formatted presenting the following the Standard Time Format pattern yyyy-MM-dd'T'HH:mm:ss.SSS'Z'" ) @RequestHeader(value="trusted-device-time", required=false) String trustedDeviceTime,@ApiParam(value = "Contains encripted parameters from the trusted device parameter source." ) @RequestHeader(value="trusted-device-params", required=false) String trustedDeviceParams,@ApiParam(value = "Filter by page (paging)") @Valid @RequestParam(value = "offset", required = false) Integer offset,@ApiParam(value = "Specific the number of elements per page (paging)") @Valid @RequestParam(value = "limit", required = false) Integer limit,@ApiParam(value = "Field that we want to sort.") @Valid @RequestParam(value = "sort", required = false) String sort,@ApiParam(value = "Direction we want to sort.") @Valid @RequestParam(value = "dir", required = false) String dir,@ApiParam(value = "Name of the plan selected by the user. The plan is related with the branch.") @Valid @RequestParam(value = "planName", required = false) String planName,@ApiParam(value = "The type associated to the recurring payment.") @Valid @RequestParam(value = "type", required = false) String type,@ApiParam(value = "Initial start time since we want to filter.") @Valid @RequestParam(value = "startTimeFrom", required = false) LocalDate startTimeFrom,@ApiParam(value = "Last start time that we want to filter.") @Valid @RequestParam(value = "startTimeTo", required = false) LocalDate startTimeTo,@ApiParam(value = "If the recurring payment have to be done again or not.") @Valid @RequestParam(value = "active", required = false) Boolean active,@ApiParam(value = "Name of the brand that we want to sort. Max length : 255 characters.") @Valid @RequestParam(value = "brand_name", required = false) String brandName,@ApiParam(value = "If the user have enabled a special configuration for the brand.") @Valid @RequestParam(value = "enabled", required = false) Boolean enabled,@ApiParam(value = "Id associated to an account. Length : 36 characters.") @Valid @RequestParam(value = "accountId", required = false) String accountId,@ApiParam(value = "Id associated to a card. Length : 36 characters.") @Valid @RequestParam(value = "cardId", required = false) String cardId,@ApiParam(value = "If the payment method in the recurring payments is ignored for the aggregation process") @Valid @RequestParam(value = "isUserRp", required = false) Boolean isUserRp);


    @ApiOperation(value = "Returns a paginated list of transaction entities.", nickname = "getTransactions", notes = "Returns a paginated list of transaction entities with possible filtering by various parameters.", response = ResponsePaginatedMaskedTransaction2.class, tags={ "Recurring Payment", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "The process finished correctly.", response = ResponsePaginatedMaskedTransaction2.class) })
    @RequestMapping(value = "/recurring-payments/transactions",
        produces = { "application/json", "application/xml" }, 
        method = RequestMethod.GET)
    ResponseEntity<ResponsePaginatedMaskedTransaction2> getTransactions(@ApiParam(value = "Field to send the access token to the API, initially OAuth and JWT." ,required=true) @RequestHeader(value="authorization", required=true) String authorization,@ApiParam(value = "The server responds with the field in the header with the response language. Following the ([ISO 639-2]-[ISO 3166-1/Alpha3]) code standard." ,required=true) @RequestHeader(value="language", required=true) String language,@ApiParam(value = "CHANNEL/SEGMENT FRONT_APP/VERSION DEVICE OS/OS_VERSION NETWORK_CLIENT/VERSION FRAMEWORK/VERSION Channel: [ISO 639-2][] plus 5 custom contry digits. For Segment: retail / business Front_App/Version: For example OneApp/1.0 Device: Platform value extracted from the device. For example iPhone13 OS/VERSION: android / iOS / windows / linux / macOS, version is a platform value extracted from the device. For example iOS/1.0 Network_Client/Version: App network client and version. For example CF_Network/5.1 Framework/Version: For example Darwin/16.3.0" ,required=true) @RequestHeader(value="device-information", required=true) String deviceInformation,@ApiParam(value = "The consumer application identifier for APIs. santander-client-id must be defined just as a Request header, this is not a header defined as an API Key at security definition level" ,required=true) @RequestHeader(value="santander-client-id", required=true) String santanderClientId,@ApiParam(value = "The consumer list of languages by order of preference. Following the (([ISO 639-2]-[ISO 3166-1/Alpha3])) code standard." ) @RequestHeader(value="accept-language", required=false) String acceptLanguage,@ApiParam(value = "The server responds with the data format of the response. Backend expected a JSON document format." ) @RequestHeader(value="content-type", required=false) String contentType,@ApiParam(value = "The consumer request the data format of the response by order of preference.Backend expected a JSON document format." ) @RequestHeader(value="accept", required=false) String accept,@ApiParam(value = "The consumer application identifier (only for IBM API Connect). Legacy. Will be reviewed in future releases." ) @RequestHeader(value="x-ibm-client-id", required=false) String xIbmClientId,@ApiParam(value = "The TraceId is 64 or 128-bit in length and indicates the overall ID of the trace. Every span in a trace shares this ID" ) @RequestHeader(value="x-b3-traceid", required=false) String xB3Traceid,@ApiParam(value = "The ParentSpanId is 64-bit in length and indicates the position of the parent operation in the trace tree. When the span is the root of the trace tree, there is no ParentSpanId." ) @RequestHeader(value="x-b3-parentspanid", required=false) String xB3Parentspanid,@ApiParam(value = "The SpanId is 64-bit in length and indicates the position of the current operation in the trace tree. The value should not be interpreted. It may or may not be derived from the value of the TraceId" ) @RequestHeader(value="x-b3-spanid", required=false) String xB3Spanid,@ApiParam(value = "Sampling is a mechanism to reduce the volume of data that ends up in the tracing system. In B3, sampling applies consistently per-trace: once the sampling decision is made, the same value should be consistently sent downstream. This means you will see all spans sharing a trace ID or none. Accepted values are\\n * 1. Means accepted\\n * 0. Means denied Before this specification was written, some tracers propagated X-B3-Sampled as true or false as opposed to 1 or 0. While you shouldn't encode x-b3-sampled as true or false, a lenient implementation may accept them" ) @RequestHeader(value="x-b3-sampled", required=false) String xB3Sampled,@ApiParam(value = "Extra information coming from the client. Needed for audit purposes" ) @RequestHeader(value="x-santander-audit", required=false) String xSantanderAudit,@ApiParam(value = "Device information permitted by operation for data query. Makes it possible to apply an experience base to optimize the data collection. This header is mandatory for Poland due to security reasons" ) @RequestHeader(value="trusted-device-app-id", required=false) String trustedDeviceAppId,@ApiParam(value = "Indicates what kind of cipher algorithmic approach will be applied to a response fields subset. Supported values: * asymmetric" ) @RequestHeader(value="santander-cipher-type", required=false) String santanderCipherType,@ApiParam(value = "Seed value applied on both sides to encrypt/decrypt response entity fields. This field is mandatory if Santander-Cipher-Type is presented and is asymetric in the request Headers collection." ) @RequestHeader(value="santander-cipher-seed", required=false) String santanderCipherSeed,@ApiParam(value = "Device time formatted presenting the following the Standard Time Format pattern yyyy-MM-dd'T'HH:mm:ss.SSS'Z'" ) @RequestHeader(value="trusted-device-time", required=false) String trustedDeviceTime,@ApiParam(value = "Contains encripted parameters from the trusted device parameter source." ) @RequestHeader(value="trusted-device-params", required=false) String trustedDeviceParams,@ApiParam(value = "Filter by page (paging)") @Valid @RequestParam(value = "offset", required = false) Integer offset,@ApiParam(value = "Specify the number of elements per page (paging).") @Valid @RequestParam(value = "limit", required = false) Integer limit,@ApiParam(value = "Initial date since we want to filter.") @Valid @RequestParam(value = "dateFrom", required = false) String dateFrom,@ApiParam(value = "Last date that we want to filter.") @Valid @RequestParam(value = "dateTo", required = false) String dateTo,@ApiParam(value = "Id associated to a recurring payment. Length : 36 characters.") @Valid @RequestParam(value = "recurringPaymentId", required = false) String recurringPaymentId,@ApiParam(value = "If it is an intuition of the system of future payments.") @Valid @RequestParam(value = "predicted", required = false) Boolean predicted,@ApiParam(value = "Id associated to a card. Length : 36 characters.") @Valid @RequestParam(value = "cardId", required = false) String cardId,@ApiParam(value = "If the payment method in the recurring payments is ignored for the aggregation process") @Valid @RequestParam(value = "isUserRp", required = false) Boolean isUserRp);


    @ApiOperation(value = "Updates the subscription list.", nickname = "updateSubscription", notes = "Updates the subscription list to set whether they're active or not store notes and the feedback of the user.", tags={ "Recurring Payment", })
    @ApiResponses(value = { 
        @ApiResponse(code = 204, message = "The process finished correctly."),
        @ApiResponse(code = 403, message = "One of the recurring payments is not associated with your user id.", response = ErrorDetails.class),
        @ApiResponse(code = 404, message = "One the recurring payment does not exist.", response = ErrorDetails.class) })
    @RequestMapping(value = "/recurring-payments",
        produces = { "application/json" }, 
        method = RequestMethod.PATCH)
    ResponseEntity<Void> updateSubscription(@ApiParam(value = ""  )  @Valid @RequestBody PatchRecurringPaymentsConfigRequest body);


    @ApiOperation(value = "Updates the subscription entity.", nickname = "updateSubscriptionById", notes = "Updates the subscription entity with the given Id with the subscription details given in the request.", tags={ "Recurring Payment", })
    @ApiResponses(value = { 
        @ApiResponse(code = 204, message = "The process finished correctly."),
        @ApiResponse(code = 403, message = "The recurring payment is not associated with your user id.", response = ErrorDetails.class),
        @ApiResponse(code = 404, message = "The recurring payment with the given id does not exist.", response = ErrorDetails.class) })
    @RequestMapping(value = "/recurring-payments/{id}",
        produces = { "application/json" }, 
        method = RequestMethod.PATCH)
    ResponseEntity<Void> updateSubscriptionById(@ApiParam(value = "Id of the recurring payment we want to search. Length : 36 characters.",required=true) @PathVariable("id") String id,@ApiParam(value = ""  )  @Valid @RequestBody PatchRecurringPaymentConfigItem body);


    @ApiOperation(value = "Updates a list of user-brands.", nickname = "updateUserBrands", notes = "Updates a list of user-brands.", response = PatchUserBrandsResponse.class, tags={ "Recurring Payment", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "The process finished correctly.", response = PatchUserBrandsResponse.class),
        @ApiResponse(code = 491, message = "The user do not have a relation with the given brand name. ", response = ErrorDetails.class) })
    @RequestMapping(value = "/recurring-payments/user-brands",
        produces = { "application/json", "application/xml" }, 
        method = RequestMethod.PATCH)
    ResponseEntity<PatchUserBrandsResponse> updateUserBrands(@ApiParam(value = "Field to send the access token to the API, initially OAuth and JWT." ,required=true) @RequestHeader(value="authorization", required=true) String authorization,@ApiParam(value = "The server responds with the field in the header with the response language. Following the ([ISO 639-2]-[ISO 3166-1/Alpha3]) code standard." ,required=true) @RequestHeader(value="language", required=true) String language,@ApiParam(value = "CHANNEL/SEGMENT FRONT_APP/VERSION DEVICE OS/OS_VERSION NETWORK_CLIENT/VERSION FRAMEWORK/VERSION Channel: [ISO 639-2][] plus 5 custom contry digits. For Segment: retail / business Front_App/Version: For example OneApp/1.0 Device: Platform value extracted from the device. For example iPhone13 OS/VERSION: android / iOS / windows / linux / macOS, version is a platform value extracted from the device. For example iOS/1.0 Network_Client/Version: App network client and version. For example CF_Network/5.1 Framework/Version: For example Darwin/16.3.0" ,required=true) @RequestHeader(value="device-information", required=true) String deviceInformation,@ApiParam(value = "The consumer application identifier for APIs. santander-client-id must be defined just as a Request header, this is not a header defined as an API Key at security definition level" ,required=true) @RequestHeader(value="santander-client-id", required=true) String santanderClientId,@ApiParam(value = "The consumer list of languages by order of preference. Following the (([ISO 639-2]-[ISO 3166-1/Alpha3])) code standard." ) @RequestHeader(value="accept-language", required=false) String acceptLanguage,@ApiParam(value = "The server responds with the data format of the response. Backend expected a JSON document format." ) @RequestHeader(value="content-type", required=false) String contentType,@ApiParam(value = "The consumer request the data format of the response by order of preference.Backend expected a JSON document format." ) @RequestHeader(value="accept", required=false) String accept,@ApiParam(value = "The consumer application identifier (only for IBM API Connect). Legacy. Will be reviewed in future releases." ) @RequestHeader(value="x-ibm-client-id", required=false) String xIbmClientId,@ApiParam(value = "The TraceId is 64 or 128-bit in length and indicates the overall ID of the trace. Every span in a trace shares this ID" ) @RequestHeader(value="x-b3-traceid", required=false) String xB3Traceid,@ApiParam(value = "The ParentSpanId is 64-bit in length and indicates the position of the parent operation in the trace tree. When the span is the root of the trace tree, there is no ParentSpanId." ) @RequestHeader(value="x-b3-parentspanid", required=false) String xB3Parentspanid,@ApiParam(value = "The SpanId is 64-bit in length and indicates the position of the current operation in the trace tree. The value should not be interpreted. It may or may not be derived from the value of the TraceId" ) @RequestHeader(value="x-b3-spanid", required=false) String xB3Spanid,@ApiParam(value = "Sampling is a mechanism to reduce the volume of data that ends up in the tracing system. In B3, sampling applies consistently per-trace: once the sampling decision is made, the same value should be consistently sent downstream. This means you will see all spans sharing a trace ID or none. Accepted values are\\n * 1. Means accepted\\n * 0. Means denied Before this specification was written, some tracers propagated X-B3-Sampled as true or false as opposed to 1 or 0. While you shouldn't encode x-b3-sampled as true or false, a lenient implementation may accept them" ) @RequestHeader(value="x-b3-sampled", required=false) String xB3Sampled,@ApiParam(value = "Extra information coming from the client. Needed for audit purposes" ) @RequestHeader(value="x-santander-audit", required=false) String xSantanderAudit,@ApiParam(value = "Device information permitted by operation for data query. Makes it possible to apply an experience base to optimize the data collection. This header is mandatory for Poland due to security reasons" ) @RequestHeader(value="trusted-device-app-id", required=false) String trustedDeviceAppId,@ApiParam(value = "Indicates what kind of cipher algorithmic approach will be applied to a response fields subset. Supported values: * asymmetric" ) @RequestHeader(value="santander-cipher-type", required=false) String santanderCipherType,@ApiParam(value = "Seed value applied on both sides to encrypt/decrypt response entity fields. This field is mandatory if Santander-Cipher-Type is presented and is asymetric in the request Headers collection." ) @RequestHeader(value="santander-cipher-seed", required=false) String santanderCipherSeed,@ApiParam(value = "Device time formatted presenting the following the Standard Time Format pattern yyyy-MM-dd'T'HH:mm:ss.SSS'Z'" ) @RequestHeader(value="trusted-device-time", required=false) String trustedDeviceTime,@ApiParam(value = "Contains encripted parameters from the trusted device parameter source." ) @RequestHeader(value="trusted-device-params", required=false) String trustedDeviceParams,@ApiParam(value = "If the payment method in the recurring payments is ignored for the aggregation process") @Valid @RequestParam(value = "isUserRp", required = false) Boolean isUserRp,@ApiParam(value = ""  )  @Valid @RequestBody PatchUserBrandRequest body);


    @ApiOperation(value = "Updates a user-brands.", nickname = "updateUserBrandsById", notes = "Updates a user-brands.", response = PatchUserBrandsResponse.class, tags={ "Recurring Payment", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "The process finished correctly.", response = PatchUserBrandsResponse.class),
        @ApiResponse(code = 491, message = "The user do not have a relation with the given brand name. ", response = ErrorDetails.class) })
    @RequestMapping(value = "/recurring-payments/user-brands/{brand_name}",
        produces = { "application/json", "application/xml" }, 
        method = RequestMethod.PATCH)
    ResponseEntity<PatchUserBrandsResponse> updateUserBrandsById(@ApiParam(value = "Field to send the access token to the API, initially OAuth and JWT." ,required=true) @RequestHeader(value="authorization", required=true) String authorization,@ApiParam(value = "The server responds with the field in the header with the response language. Following the ([ISO 639-2]-[ISO 3166-1/Alpha3]) code standard." ,required=true) @RequestHeader(value="language", required=true) String language,@ApiParam(value = "CHANNEL/SEGMENT FRONT_APP/VERSION DEVICE OS/OS_VERSION NETWORK_CLIENT/VERSION FRAMEWORK/VERSION Channel: [ISO 639-2][] plus 5 custom contry digits. For Segment: retail / business Front_App/Version: For example OneApp/1.0 Device: Platform value extracted from the device. For example iPhone13 OS/VERSION: android / iOS / windows / linux / macOS, version is a platform value extracted from the device. For example iOS/1.0 Network_Client/Version: App network client and version. For example CF_Network/5.1 Framework/Version: For example Darwin/16.3.0" ,required=true) @RequestHeader(value="device-information", required=true) String deviceInformation,@ApiParam(value = "The consumer application identifier for APIs. santander-client-id must be defined just as a Request header, this is not a header defined as an API Key at security definition level" ,required=true) @RequestHeader(value="santander-client-id", required=true) String santanderClientId,@ApiParam(value = "Name of the brand that we want to sort. Max length : 255 characters.",required=true) @PathVariable("brand_name") String brandName,@ApiParam(value = "The consumer list of languages by order of preference. Following the (([ISO 639-2]-[ISO 3166-1/Alpha3])) code standard." ) @RequestHeader(value="accept-language", required=false) String acceptLanguage,@ApiParam(value = "The server responds with the data format of the response. Backend expected a JSON document format." ) @RequestHeader(value="content-type", required=false) String contentType,@ApiParam(value = "The consumer request the data format of the response by order of preference.Backend expected a JSON document format." ) @RequestHeader(value="accept", required=false) String accept,@ApiParam(value = "The consumer application identifier (only for IBM API Connect). Legacy. Will be reviewed in future releases." ) @RequestHeader(value="x-ibm-client-id", required=false) String xIbmClientId,@ApiParam(value = "The TraceId is 64 or 128-bit in length and indicates the overall ID of the trace. Every span in a trace shares this ID" ) @RequestHeader(value="x-b3-traceid", required=false) String xB3Traceid,@ApiParam(value = "The ParentSpanId is 64-bit in length and indicates the position of the parent operation in the trace tree. When the span is the root of the trace tree, there is no ParentSpanId." ) @RequestHeader(value="x-b3-parentspanid", required=false) String xB3Parentspanid,@ApiParam(value = "The SpanId is 64-bit in length and indicates the position of the current operation in the trace tree. The value should not be interpreted. It may or may not be derived from the value of the TraceId" ) @RequestHeader(value="x-b3-spanid", required=false) String xB3Spanid,@ApiParam(value = "Sampling is a mechanism to reduce the volume of data that ends up in the tracing system. In B3, sampling applies consistently per-trace: once the sampling decision is made, the same value should be consistently sent downstream. This means you will see all spans sharing a trace ID or none. Accepted values are\\n * 1. Means accepted\\n * 0. Means denied Before this specification was written, some tracers propagated X-B3-Sampled as true or false as opposed to 1 or 0. While you shouldn't encode x-b3-sampled as true or false, a lenient implementation may accept them" ) @RequestHeader(value="x-b3-sampled", required=false) String xB3Sampled,@ApiParam(value = "Extra information coming from the client. Needed for audit purposes" ) @RequestHeader(value="x-santander-audit", required=false) String xSantanderAudit,@ApiParam(value = "Device information permitted by operation for data query. Makes it possible to apply an experience base to optimize the data collection. This header is mandatory for Poland due to security reasons" ) @RequestHeader(value="trusted-device-app-id", required=false) String trustedDeviceAppId,@ApiParam(value = "Indicates what kind of cipher algorithmic approach will be applied to a response fields subset. Supported values: * asymmetric" ) @RequestHeader(value="santander-cipher-type", required=false) String santanderCipherType,@ApiParam(value = "Seed value applied on both sides to encrypt/decrypt response entity fields. This field is mandatory if Santander-Cipher-Type is presented and is asymetric in the request Headers collection." ) @RequestHeader(value="santander-cipher-seed", required=false) String santanderCipherSeed,@ApiParam(value = "Device time formatted presenting the following the Standard Time Format pattern yyyy-MM-dd'T'HH:mm:ss.SSS'Z'" ) @RequestHeader(value="trusted-device-time", required=false) String trustedDeviceTime,@ApiParam(value = "Contains encripted parameters from the trusted device parameter source." ) @RequestHeader(value="trusted-device-params", required=false) String trustedDeviceParams,@ApiParam(value = "If the payment method in the recurring payments is ignored for the aggregation process") @Valid @RequestParam(value = "isUserRp", required = false) Boolean isUserRp,@ApiParam(value = ""  )  @Valid @RequestBody PatchUserBrandItem body);

}
